// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package main

import (
	"context"
	"github.com/elnoro/foxyshot-indexer/internal/domain"
	"sync"
)

// Ensure, that imageRepoMock does implement imageRepo.
// If this is not the case, regenerate this file with moq.
var _ imageRepo = &imageRepoMock{}

// imageRepoMock is a mock implementation of imageRepo.
//
//	func TestSomethingThatUsesimageRepo(t *testing.T) {
//
//		// make and configure a mocked imageRepo
//		mockedimageRepo := &imageRepoMock{
//			DeleteFunc: func(ctx context.Context, fileID string) error {
//				panic("mock out the Delete method")
//			},
//			FindByDescriptionFunc: func(ctx context.Context, searchString string, page int, perPage int) ([]domain.Image, error) {
//				panic("mock out the FindByDescription method")
//			},
//			FindByEmbeddingFunc: func(ctx context.Context, embedding domain.Embedding, page int, perPage int) ([]domain.Image, error) {
//				panic("mock out the FindByEmbedding method")
//			},
//		}
//
//		// use mockedimageRepo in code that requires imageRepo
//		// and then make assertions.
//
//	}
type imageRepoMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, fileID string) error

	// FindByDescriptionFunc mocks the FindByDescription method.
	FindByDescriptionFunc func(ctx context.Context, searchString string, page int, perPage int) ([]domain.Image, error)

	// FindByEmbeddingFunc mocks the FindByEmbedding method.
	FindByEmbeddingFunc func(ctx context.Context, embedding domain.Embedding, page int, perPage int) ([]domain.Image, error)

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FileID is the fileID argument value.
			FileID string
		}
		// FindByDescription holds details about calls to the FindByDescription method.
		FindByDescription []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SearchString is the searchString argument value.
			SearchString string
			// Page is the page argument value.
			Page int
			// PerPage is the perPage argument value.
			PerPage int
		}
		// FindByEmbedding holds details about calls to the FindByEmbedding method.
		FindByEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Embedding is the embedding argument value.
			Embedding domain.Embedding
			// Page is the page argument value.
			Page int
			// PerPage is the perPage argument value.
			PerPage int
		}
	}
	lockDelete            sync.RWMutex
	lockFindByDescription sync.RWMutex
	lockFindByEmbedding   sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *imageRepoMock) Delete(ctx context.Context, fileID string) error {
	if mock.DeleteFunc == nil {
		panic("imageRepoMock.DeleteFunc: method is nil but imageRepo.Delete was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		FileID string
	}{
		Ctx:    ctx,
		FileID: fileID,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, fileID)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedimageRepo.DeleteCalls())
func (mock *imageRepoMock) DeleteCalls() []struct {
	Ctx    context.Context
	FileID string
} {
	var calls []struct {
		Ctx    context.Context
		FileID string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// FindByDescription calls FindByDescriptionFunc.
func (mock *imageRepoMock) FindByDescription(ctx context.Context, searchString string, page int, perPage int) ([]domain.Image, error) {
	if mock.FindByDescriptionFunc == nil {
		panic("imageRepoMock.FindByDescriptionFunc: method is nil but imageRepo.FindByDescription was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		SearchString string
		Page         int
		PerPage      int
	}{
		Ctx:          ctx,
		SearchString: searchString,
		Page:         page,
		PerPage:      perPage,
	}
	mock.lockFindByDescription.Lock()
	mock.calls.FindByDescription = append(mock.calls.FindByDescription, callInfo)
	mock.lockFindByDescription.Unlock()
	return mock.FindByDescriptionFunc(ctx, searchString, page, perPage)
}

// FindByDescriptionCalls gets all the calls that were made to FindByDescription.
// Check the length with:
//
//	len(mockedimageRepo.FindByDescriptionCalls())
func (mock *imageRepoMock) FindByDescriptionCalls() []struct {
	Ctx          context.Context
	SearchString string
	Page         int
	PerPage      int
} {
	var calls []struct {
		Ctx          context.Context
		SearchString string
		Page         int
		PerPage      int
	}
	mock.lockFindByDescription.RLock()
	calls = mock.calls.FindByDescription
	mock.lockFindByDescription.RUnlock()
	return calls
}

// FindByEmbedding calls FindByEmbeddingFunc.
func (mock *imageRepoMock) FindByEmbedding(ctx context.Context, embedding domain.Embedding, page int, perPage int) ([]domain.Image, error) {
	if mock.FindByEmbeddingFunc == nil {
		panic("imageRepoMock.FindByEmbeddingFunc: method is nil but imageRepo.FindByEmbedding was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Embedding domain.Embedding
		Page      int
		PerPage   int
	}{
		Ctx:       ctx,
		Embedding: embedding,
		Page:      page,
		PerPage:   perPage,
	}
	mock.lockFindByEmbedding.Lock()
	mock.calls.FindByEmbedding = append(mock.calls.FindByEmbedding, callInfo)
	mock.lockFindByEmbedding.Unlock()
	return mock.FindByEmbeddingFunc(ctx, embedding, page, perPage)
}

// FindByEmbeddingCalls gets all the calls that were made to FindByEmbedding.
// Check the length with:
//
//	len(mockedimageRepo.FindByEmbeddingCalls())
func (mock *imageRepoMock) FindByEmbeddingCalls() []struct {
	Ctx       context.Context
	Embedding domain.Embedding
	Page      int
	PerPage   int
} {
	var calls []struct {
		Ctx       context.Context
		Embedding domain.Embedding
		Page      int
		PerPage   int
	}
	mock.lockFindByEmbedding.RLock()
	calls = mock.calls.FindByEmbedding
	mock.lockFindByEmbedding.RUnlock()
	return calls
}

// Ensure, that fileStorageMock does implement fileStorage.
// If this is not the case, regenerate this file with moq.
var _ fileStorage = &fileStorageMock{}

// fileStorageMock is a mock implementation of fileStorage.
//
//	func TestSomethingThatUsesfileStorage(t *testing.T) {
//
//		// make and configure a mocked fileStorage
//		mockedfileStorage := &fileStorageMock{
//			DeleteFileFunc: func(ctx context.Context, key string) error {
//				panic("mock out the DeleteFile method")
//			},
//		}
//
//		// use mockedfileStorage in code that requires fileStorage
//		// and then make assertions.
//
//	}
type fileStorageMock struct {
	// DeleteFileFunc mocks the DeleteFile method.
	DeleteFileFunc func(ctx context.Context, key string) error

	// calls tracks calls to the methods.
	calls struct {
		// DeleteFile holds details about calls to the DeleteFile method.
		DeleteFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
	}
	lockDeleteFile sync.RWMutex
}

// DeleteFile calls DeleteFileFunc.
func (mock *fileStorageMock) DeleteFile(ctx context.Context, key string) error {
	if mock.DeleteFileFunc == nil {
		panic("fileStorageMock.DeleteFileFunc: method is nil but fileStorage.DeleteFile was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDeleteFile.Lock()
	mock.calls.DeleteFile = append(mock.calls.DeleteFile, callInfo)
	mock.lockDeleteFile.Unlock()
	return mock.DeleteFileFunc(ctx, key)
}

// DeleteFileCalls gets all the calls that were made to DeleteFile.
// Check the length with:
//
//	len(mockedfileStorage.DeleteFileCalls())
func (mock *fileStorageMock) DeleteFileCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDeleteFile.RLock()
	calls = mock.calls.DeleteFile
	mock.lockDeleteFile.RUnlock()
	return calls
}
