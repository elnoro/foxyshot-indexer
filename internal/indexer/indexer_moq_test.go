// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package indexer

import (
	"context"
	"github.com/elnoro/foxyshot-indexer/internal/domain"
	"os"
	"sync"
	"time"
)

// Ensure, that ImageRepoMock does implement ImageRepo.
// If this is not the case, regenerate this file with moq.
var _ ImageRepo = &ImageRepoMock{}

// ImageRepoMock is a mock implementation of ImageRepo.
//
//	func TestSomethingThatUsesImageRepo(t *testing.T) {
//
//		// make and configure a mocked ImageRepo
//		mockedImageRepo := &ImageRepoMock{
//			GetFunc: func(ctx context.Context, fileID string) (domain.Image, error) {
//				panic("mock out the Get method")
//			},
//			GetLastModifiedFunc: func(ctx context.Context) (time.Time, error) {
//				panic("mock out the GetLastModified method")
//			},
//			UpsertFunc: func(ctx context.Context, image domain.Image) error {
//				panic("mock out the Upsert method")
//			},
//		}
//
//		// use mockedImageRepo in code that requires ImageRepo
//		// and then make assertions.
//
//	}
type ImageRepoMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, fileID string) (domain.Image, error)

	// GetLastModifiedFunc mocks the GetLastModified method.
	GetLastModifiedFunc func(ctx context.Context) (time.Time, error)

	// UpsertFunc mocks the Upsert method.
	UpsertFunc func(ctx context.Context, image domain.Image) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FileID is the fileID argument value.
			FileID string
		}
		// GetLastModified holds details about calls to the GetLastModified method.
		GetLastModified []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Upsert holds details about calls to the Upsert method.
		Upsert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Image is the image argument value.
			Image domain.Image
		}
	}
	lockGet             sync.RWMutex
	lockGetLastModified sync.RWMutex
	lockUpsert          sync.RWMutex
}

// Get calls GetFunc.
func (mock *ImageRepoMock) Get(ctx context.Context, fileID string) (domain.Image, error) {
	if mock.GetFunc == nil {
		panic("ImageRepoMock.GetFunc: method is nil but ImageRepo.Get was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		FileID string
	}{
		Ctx:    ctx,
		FileID: fileID,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, fileID)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedImageRepo.GetCalls())
func (mock *ImageRepoMock) GetCalls() []struct {
	Ctx    context.Context
	FileID string
} {
	var calls []struct {
		Ctx    context.Context
		FileID string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetLastModified calls GetLastModifiedFunc.
func (mock *ImageRepoMock) GetLastModified(ctx context.Context) (time.Time, error) {
	if mock.GetLastModifiedFunc == nil {
		panic("ImageRepoMock.GetLastModifiedFunc: method is nil but ImageRepo.GetLastModified was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLastModified.Lock()
	mock.calls.GetLastModified = append(mock.calls.GetLastModified, callInfo)
	mock.lockGetLastModified.Unlock()
	return mock.GetLastModifiedFunc(ctx)
}

// GetLastModifiedCalls gets all the calls that were made to GetLastModified.
// Check the length with:
//
//	len(mockedImageRepo.GetLastModifiedCalls())
func (mock *ImageRepoMock) GetLastModifiedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetLastModified.RLock()
	calls = mock.calls.GetLastModified
	mock.lockGetLastModified.RUnlock()
	return calls
}

// Upsert calls UpsertFunc.
func (mock *ImageRepoMock) Upsert(ctx context.Context, image domain.Image) error {
	if mock.UpsertFunc == nil {
		panic("ImageRepoMock.UpsertFunc: method is nil but ImageRepo.Upsert was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Image domain.Image
	}{
		Ctx:   ctx,
		Image: image,
	}
	mock.lockUpsert.Lock()
	mock.calls.Upsert = append(mock.calls.Upsert, callInfo)
	mock.lockUpsert.Unlock()
	return mock.UpsertFunc(ctx, image)
}

// UpsertCalls gets all the calls that were made to Upsert.
// Check the length with:
//
//	len(mockedImageRepo.UpsertCalls())
func (mock *ImageRepoMock) UpsertCalls() []struct {
	Ctx   context.Context
	Image domain.Image
} {
	var calls []struct {
		Ctx   context.Context
		Image domain.Image
	}
	mock.lockUpsert.RLock()
	calls = mock.calls.Upsert
	mock.lockUpsert.RUnlock()
	return calls
}

// Ensure, that FileStorageMock does implement FileStorage.
// If this is not the case, regenerate this file with moq.
var _ FileStorage = &FileStorageMock{}

// FileStorageMock is a mock implementation of FileStorage.
//
//	func TestSomethingThatUsesFileStorage(t *testing.T) {
//
//		// make and configure a mocked FileStorage
//		mockedFileStorage := &FileStorageMock{
//			DownloadFunc: func(key string) (*os.File, error) {
//				panic("mock out the Download method")
//			},
//			ListFilesFunc: func(start time.Time, ext string) ([]domain.File, error) {
//				panic("mock out the ListFiles method")
//			},
//		}
//
//		// use mockedFileStorage in code that requires FileStorage
//		// and then make assertions.
//
//	}
type FileStorageMock struct {
	// DownloadFunc mocks the Download method.
	DownloadFunc func(key string) (*os.File, error)

	// ListFilesFunc mocks the ListFiles method.
	ListFilesFunc func(start time.Time, ext string) ([]domain.File, error)

	// calls tracks calls to the methods.
	calls struct {
		// Download holds details about calls to the Download method.
		Download []struct {
			// Key is the key argument value.
			Key string
		}
		// ListFiles holds details about calls to the ListFiles method.
		ListFiles []struct {
			// Start is the start argument value.
			Start time.Time
			// Ext is the ext argument value.
			Ext string
		}
	}
	lockDownload  sync.RWMutex
	lockListFiles sync.RWMutex
}

// Download calls DownloadFunc.
func (mock *FileStorageMock) Download(key string) (*os.File, error) {
	if mock.DownloadFunc == nil {
		panic("FileStorageMock.DownloadFunc: method is nil but FileStorage.Download was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockDownload.Lock()
	mock.calls.Download = append(mock.calls.Download, callInfo)
	mock.lockDownload.Unlock()
	return mock.DownloadFunc(key)
}

// DownloadCalls gets all the calls that were made to Download.
// Check the length with:
//
//	len(mockedFileStorage.DownloadCalls())
func (mock *FileStorageMock) DownloadCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockDownload.RLock()
	calls = mock.calls.Download
	mock.lockDownload.RUnlock()
	return calls
}

// ListFiles calls ListFilesFunc.
func (mock *FileStorageMock) ListFiles(start time.Time, ext string) ([]domain.File, error) {
	if mock.ListFilesFunc == nil {
		panic("FileStorageMock.ListFilesFunc: method is nil but FileStorage.ListFiles was just called")
	}
	callInfo := struct {
		Start time.Time
		Ext   string
	}{
		Start: start,
		Ext:   ext,
	}
	mock.lockListFiles.Lock()
	mock.calls.ListFiles = append(mock.calls.ListFiles, callInfo)
	mock.lockListFiles.Unlock()
	return mock.ListFilesFunc(start, ext)
}

// ListFilesCalls gets all the calls that were made to ListFiles.
// Check the length with:
//
//	len(mockedFileStorage.ListFilesCalls())
func (mock *FileStorageMock) ListFilesCalls() []struct {
	Start time.Time
	Ext   string
} {
	var calls []struct {
		Start time.Time
		Ext   string
	}
	mock.lockListFiles.RLock()
	calls = mock.calls.ListFiles
	mock.lockListFiles.RUnlock()
	return calls
}

// Ensure, that OCRMock does implement OCR.
// If this is not the case, regenerate this file with moq.
var _ OCR = &OCRMock{}

// OCRMock is a mock implementation of OCR.
//
//	func TestSomethingThatUsesOCR(t *testing.T) {
//
//		// make and configure a mocked OCR
//		mockedOCR := &OCRMock{
//			RunFunc: func(file string) (string, error) {
//				panic("mock out the Run method")
//			},
//		}
//
//		// use mockedOCR in code that requires OCR
//		// and then make assertions.
//
//	}
type OCRMock struct {
	// RunFunc mocks the Run method.
	RunFunc func(file string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Run holds details about calls to the Run method.
		Run []struct {
			// File is the file argument value.
			File string
		}
	}
	lockRun sync.RWMutex
}

// Run calls RunFunc.
func (mock *OCRMock) Run(file string) (string, error) {
	if mock.RunFunc == nil {
		panic("OCRMock.RunFunc: method is nil but OCR.Run was just called")
	}
	callInfo := struct {
		File string
	}{
		File: file,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	return mock.RunFunc(file)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedOCR.RunCalls())
func (mock *OCRMock) RunCalls() []struct {
	File string
} {
	var calls []struct {
		File string
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// Ensure, that CaptionSmithMock does implement CaptionSmith.
// If this is not the case, regenerate this file with moq.
var _ CaptionSmith = &CaptionSmithMock{}

// CaptionSmithMock is a mock implementation of CaptionSmith.
//
//	func TestSomethingThatUsesCaptionSmith(t *testing.T) {
//
//		// make and configure a mocked CaptionSmith
//		mockedCaptionSmith := &CaptionSmithMock{
//			CaptionFunc: func(filename string) (string, error) {
//				panic("mock out the Caption method")
//			},
//		}
//
//		// use mockedCaptionSmith in code that requires CaptionSmith
//		// and then make assertions.
//
//	}
type CaptionSmithMock struct {
	// CaptionFunc mocks the Caption method.
	CaptionFunc func(filename string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Caption holds details about calls to the Caption method.
		Caption []struct {
			// Filename is the filename argument value.
			Filename string
		}
	}
	lockCaption sync.RWMutex
}

// Caption calls CaptionFunc.
func (mock *CaptionSmithMock) Caption(filename string) (string, error) {
	if mock.CaptionFunc == nil {
		panic("CaptionSmithMock.CaptionFunc: method is nil but CaptionSmith.Caption was just called")
	}
	callInfo := struct {
		Filename string
	}{
		Filename: filename,
	}
	mock.lockCaption.Lock()
	mock.calls.Caption = append(mock.calls.Caption, callInfo)
	mock.lockCaption.Unlock()
	return mock.CaptionFunc(filename)
}

// CaptionCalls gets all the calls that were made to Caption.
// Check the length with:
//
//	len(mockedCaptionSmith.CaptionCalls())
func (mock *CaptionSmithMock) CaptionCalls() []struct {
	Filename string
} {
	var calls []struct {
		Filename string
	}
	mock.lockCaption.RLock()
	calls = mock.calls.Caption
	mock.lockCaption.RUnlock()
	return calls
}

// Ensure, that ImageEmbeddingClientMock does implement ImageEmbeddingClient.
// If this is not the case, regenerate this file with moq.
var _ ImageEmbeddingClient = &ImageEmbeddingClientMock{}

// ImageEmbeddingClientMock is a mock implementation of ImageEmbeddingClient.
//
//	func TestSomethingThatUsesImageEmbeddingClient(t *testing.T) {
//
//		// make and configure a mocked ImageEmbeddingClient
//		mockedImageEmbeddingClient := &ImageEmbeddingClientMock{
//			CreateEmbeddingForFileFunc: func(filePath string) (domain.Embedding, error) {
//				panic("mock out the CreateEmbeddingForFile method")
//			},
//			CreateEmbeddingFromBase64Func: func(data string) (domain.Embedding, error) {
//				panic("mock out the CreateEmbeddingFromBase64 method")
//			},
//		}
//
//		// use mockedImageEmbeddingClient in code that requires ImageEmbeddingClient
//		// and then make assertions.
//
//	}
type ImageEmbeddingClientMock struct {
	// CreateEmbeddingForFileFunc mocks the CreateEmbeddingForFile method.
	CreateEmbeddingForFileFunc func(filePath string) (domain.Embedding, error)

	// CreateEmbeddingFromBase64Func mocks the CreateEmbeddingFromBase64 method.
	CreateEmbeddingFromBase64Func func(data string) (domain.Embedding, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateEmbeddingForFile holds details about calls to the CreateEmbeddingForFile method.
		CreateEmbeddingForFile []struct {
			// FilePath is the filePath argument value.
			FilePath string
		}
		// CreateEmbeddingFromBase64 holds details about calls to the CreateEmbeddingFromBase64 method.
		CreateEmbeddingFromBase64 []struct {
			// Data is the data argument value.
			Data string
		}
	}
	lockCreateEmbeddingForFile    sync.RWMutex
	lockCreateEmbeddingFromBase64 sync.RWMutex
}

// CreateEmbeddingForFile calls CreateEmbeddingForFileFunc.
func (mock *ImageEmbeddingClientMock) CreateEmbeddingForFile(filePath string) (domain.Embedding, error) {
	if mock.CreateEmbeddingForFileFunc == nil {
		panic("ImageEmbeddingClientMock.CreateEmbeddingForFileFunc: method is nil but ImageEmbeddingClient.CreateEmbeddingForFile was just called")
	}
	callInfo := struct {
		FilePath string
	}{
		FilePath: filePath,
	}
	mock.lockCreateEmbeddingForFile.Lock()
	mock.calls.CreateEmbeddingForFile = append(mock.calls.CreateEmbeddingForFile, callInfo)
	mock.lockCreateEmbeddingForFile.Unlock()
	return mock.CreateEmbeddingForFileFunc(filePath)
}

// CreateEmbeddingForFileCalls gets all the calls that were made to CreateEmbeddingForFile.
// Check the length with:
//
//	len(mockedImageEmbeddingClient.CreateEmbeddingForFileCalls())
func (mock *ImageEmbeddingClientMock) CreateEmbeddingForFileCalls() []struct {
	FilePath string
} {
	var calls []struct {
		FilePath string
	}
	mock.lockCreateEmbeddingForFile.RLock()
	calls = mock.calls.CreateEmbeddingForFile
	mock.lockCreateEmbeddingForFile.RUnlock()
	return calls
}

// CreateEmbeddingFromBase64 calls CreateEmbeddingFromBase64Func.
func (mock *ImageEmbeddingClientMock) CreateEmbeddingFromBase64(data string) (domain.Embedding, error) {
	if mock.CreateEmbeddingFromBase64Func == nil {
		panic("ImageEmbeddingClientMock.CreateEmbeddingFromBase64Func: method is nil but ImageEmbeddingClient.CreateEmbeddingFromBase64 was just called")
	}
	callInfo := struct {
		Data string
	}{
		Data: data,
	}
	mock.lockCreateEmbeddingFromBase64.Lock()
	mock.calls.CreateEmbeddingFromBase64 = append(mock.calls.CreateEmbeddingFromBase64, callInfo)
	mock.lockCreateEmbeddingFromBase64.Unlock()
	return mock.CreateEmbeddingFromBase64Func(data)
}

// CreateEmbeddingFromBase64Calls gets all the calls that were made to CreateEmbeddingFromBase64.
// Check the length with:
//
//	len(mockedImageEmbeddingClient.CreateEmbeddingFromBase64Calls())
func (mock *ImageEmbeddingClientMock) CreateEmbeddingFromBase64Calls() []struct {
	Data string
} {
	var calls []struct {
		Data string
	}
	mock.lockCreateEmbeddingFromBase64.RLock()
	calls = mock.calls.CreateEmbeddingFromBase64
	mock.lockCreateEmbeddingFromBase64.RUnlock()
	return calls
}
