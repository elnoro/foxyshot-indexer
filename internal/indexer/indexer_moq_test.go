// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package indexer

import (
	"context"
	"github.com/elnoro/foxyshot-indexer/internal/domain"
	"os"
	"sync"
)

// Ensure, that ImageRepoMock does implement ImageRepo.
// If this is not the case, regenerate this file with moq.
var _ ImageRepo = &ImageRepoMock{}

// ImageRepoMock is a mock implementation of ImageRepo.
//
//	func TestSomethingThatUsesImageRepo(t *testing.T) {
//
//		// make and configure a mocked ImageRepo
//		mockedImageRepo := &ImageRepoMock{
//			UpsertFunc: func(image domain.Image) error {
//				panic("mock out the Upsert method")
//			},
//		}
//
//		// use mockedImageRepo in code that requires ImageRepo
//		// and then make assertions.
//
//	}
type ImageRepoMock struct {
	// UpsertFunc mocks the Upsert method.
	UpsertFunc func(image domain.Image) error

	// calls tracks calls to the methods.
	calls struct {
		// Upsert holds details about calls to the Upsert method.
		Upsert []struct {
			// Image is the image argument value.
			Image domain.Image
		}
	}
	lockUpsert sync.RWMutex
}

// Upsert calls UpsertFunc.
func (mock *ImageRepoMock) Upsert(ctx context.Context, image domain.Image) error {
	if mock.UpsertFunc == nil {
		panic("ImageRepoMock.UpsertFunc: method is nil but ImageRepo.Upsert was just called")
	}
	callInfo := struct {
		Image domain.Image
	}{
		Image: image,
	}
	mock.lockUpsert.Lock()
	mock.calls.Upsert = append(mock.calls.Upsert, callInfo)
	mock.lockUpsert.Unlock()
	return mock.UpsertFunc(image)
}

// UpsertCalls gets all the calls that were made to Upsert.
// Check the length with:
//
//	len(mockedImageRepo.UpsertCalls())
func (mock *ImageRepoMock) UpsertCalls() []struct {
	Image domain.Image
} {
	var calls []struct {
		Image domain.Image
	}
	mock.lockUpsert.RLock()
	calls = mock.calls.Upsert
	mock.lockUpsert.RUnlock()
	return calls
}

// Ensure, that FileStorageMock does implement FileStorage.
// If this is not the case, regenerate this file with moq.
var _ FileStorage = &FileStorageMock{}

// FileStorageMock is a mock implementation of FileStorage.
//
//	func TestSomethingThatUsesFileStorage(t *testing.T) {
//
//		// make and configure a mocked FileStorage
//		mockedFileStorage := &FileStorageMock{
//			DownloadFunc: func(key string) (*os.File, error) {
//				panic("mock out the Download method")
//			},
//		}
//
//		// use mockedFileStorage in code that requires FileStorage
//		// and then make assertions.
//
//	}
type FileStorageMock struct {
	// DownloadFunc mocks the Download method.
	DownloadFunc func(key string) (*os.File, error)

	// calls tracks calls to the methods.
	calls struct {
		// Download holds details about calls to the Download method.
		Download []struct {
			// Key is the key argument value.
			Key string
		}
	}
	lockDownload sync.RWMutex
}

// Download calls DownloadFunc.
func (mock *FileStorageMock) Download(key string) (*os.File, error) {
	if mock.DownloadFunc == nil {
		panic("FileStorageMock.DownloadFunc: method is nil but FileStorage.Download was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockDownload.Lock()
	mock.calls.Download = append(mock.calls.Download, callInfo)
	mock.lockDownload.Unlock()
	return mock.DownloadFunc(key)
}

// DownloadCalls gets all the calls that were made to Download.
// Check the length with:
//
//	len(mockedFileStorage.DownloadCalls())
func (mock *FileStorageMock) DownloadCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockDownload.RLock()
	calls = mock.calls.Download
	mock.lockDownload.RUnlock()
	return calls
}

// Ensure, that OCRMock does implement OCR.
// If this is not the case, regenerate this file with moq.
var _ OCR = &OCRMock{}

// OCRMock is a mock implementation of OCR.
//
//	func TestSomethingThatUsesOCR(t *testing.T) {
//
//		// make and configure a mocked OCR
//		mockedOCR := &OCRMock{
//			RunFunc: func(file string) (string, error) {
//				panic("mock out the Run method")
//			},
//		}
//
//		// use mockedOCR in code that requires OCR
//		// and then make assertions.
//
//	}
type OCRMock struct {
	// RunFunc mocks the Run method.
	RunFunc func(file string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Run holds details about calls to the Run method.
		Run []struct {
			// File is the file argument value.
			File string
		}
	}
	lockRun sync.RWMutex
}

// Run calls RunFunc.
func (mock *OCRMock) Run(file string) (string, error) {
	if mock.RunFunc == nil {
		panic("OCRMock.RunFunc: method is nil but OCR.Run was just called")
	}
	callInfo := struct {
		File string
	}{
		File: file,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	return mock.RunFunc(file)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedOCR.RunCalls())
func (mock *OCRMock) RunCalls() []struct {
	File string
} {
	var calls []struct {
		File string
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}
