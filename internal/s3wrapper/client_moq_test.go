// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package s3wrapper

import (
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/aws/aws-sdk-go/service/s3/s3manager"
	"io"
	"sync"
)

// Ensure, that downloaderMock does implement downloader.
// If this is not the case, regenerate this file with moq.
var _ downloader = &downloaderMock{}

// downloaderMock is a mock implementation of downloader.
//
//	func TestSomethingThatUsesdownloader(t *testing.T) {
//
//		// make and configure a mocked downloader
//		mockeddownloader := &downloaderMock{
//			DownloadFunc: func(writerAt io.WriterAt, getObjectInput *s3.GetObjectInput, fns ...func(*s3manager.Downloader)) (int64, error) {
//				panic("mock out the Download method")
//			},
//		}
//
//		// use mockeddownloader in code that requires downloader
//		// and then make assertions.
//
//	}
type downloaderMock struct {
	// DownloadFunc mocks the Download method.
	DownloadFunc func(writerAt io.WriterAt, getObjectInput *s3.GetObjectInput, fns ...func(*s3manager.Downloader)) (int64, error)

	// calls tracks calls to the methods.
	calls struct {
		// Download holds details about calls to the Download method.
		Download []struct {
			// WriterAt is the writerAt argument value.
			WriterAt io.WriterAt
			// GetObjectInput is the getObjectInput argument value.
			GetObjectInput *s3.GetObjectInput
			// Fns is the fns argument value.
			Fns []func(*s3manager.Downloader)
		}
	}
	lockDownload sync.RWMutex
}

// Download calls DownloadFunc.
func (mock *downloaderMock) Download(writerAt io.WriterAt, getObjectInput *s3.GetObjectInput, fns ...func(*s3manager.Downloader)) (int64, error) {
	if mock.DownloadFunc == nil {
		panic("downloaderMock.DownloadFunc: method is nil but downloader.Download was just called")
	}
	callInfo := struct {
		WriterAt       io.WriterAt
		GetObjectInput *s3.GetObjectInput
		Fns            []func(*s3manager.Downloader)
	}{
		WriterAt:       writerAt,
		GetObjectInput: getObjectInput,
		Fns:            fns,
	}
	mock.lockDownload.Lock()
	mock.calls.Download = append(mock.calls.Download, callInfo)
	mock.lockDownload.Unlock()
	return mock.DownloadFunc(writerAt, getObjectInput, fns...)
}

// DownloadCalls gets all the calls that were made to Download.
// Check the length with:
//
//	len(mockeddownloader.DownloadCalls())
func (mock *downloaderMock) DownloadCalls() []struct {
	WriterAt       io.WriterAt
	GetObjectInput *s3.GetObjectInput
	Fns            []func(*s3manager.Downloader)
} {
	var calls []struct {
		WriterAt       io.WriterAt
		GetObjectInput *s3.GetObjectInput
		Fns            []func(*s3manager.Downloader)
	}
	mock.lockDownload.RLock()
	calls = mock.calls.Download
	mock.lockDownload.RUnlock()
	return calls
}

// Ensure, that clientMock does implement client.
// If this is not the case, regenerate this file with moq.
var _ client = &clientMock{}

// clientMock is a mock implementation of client.
//
//	func TestSomethingThatUsesclient(t *testing.T) {
//
//		// make and configure a mocked client
//		mockedclient := &clientMock{
//			DeleteObjectFunc: func(object *s3.DeleteObjectInput) (*s3.DeleteObjectOutput, error) {
//				panic("mock out the DeleteObject method")
//			},
//			HeadBucketFunc: func(headBucketInput *s3.HeadBucketInput) (*s3.HeadBucketOutput, error) {
//				panic("mock out the HeadBucket method")
//			},
//			ListObjectsV2Func: func(listObjectsV2Input *s3.ListObjectsV2Input) (*s3.ListObjectsV2Output, error) {
//				panic("mock out the ListObjectsV2 method")
//			},
//		}
//
//		// use mockedclient in code that requires client
//		// and then make assertions.
//
//	}
type clientMock struct {
	// DeleteObjectFunc mocks the DeleteObject method.
	DeleteObjectFunc func(object *s3.DeleteObjectInput) (*s3.DeleteObjectOutput, error)

	// HeadBucketFunc mocks the HeadBucket method.
	HeadBucketFunc func(headBucketInput *s3.HeadBucketInput) (*s3.HeadBucketOutput, error)

	// ListObjectsV2Func mocks the ListObjectsV2 method.
	ListObjectsV2Func func(listObjectsV2Input *s3.ListObjectsV2Input) (*s3.ListObjectsV2Output, error)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteObject holds details about calls to the DeleteObject method.
		DeleteObject []struct {
			// Object is the object argument value.
			Object *s3.DeleteObjectInput
		}
		// HeadBucket holds details about calls to the HeadBucket method.
		HeadBucket []struct {
			// HeadBucketInput is the headBucketInput argument value.
			HeadBucketInput *s3.HeadBucketInput
		}
		// ListObjectsV2 holds details about calls to the ListObjectsV2 method.
		ListObjectsV2 []struct {
			// ListObjectsV2Input is the listObjectsV2Input argument value.
			ListObjectsV2Input *s3.ListObjectsV2Input
		}
	}
	lockDeleteObject  sync.RWMutex
	lockHeadBucket    sync.RWMutex
	lockListObjectsV2 sync.RWMutex
}

// DeleteObject calls DeleteObjectFunc.
func (mock *clientMock) DeleteObject(object *s3.DeleteObjectInput) (*s3.DeleteObjectOutput, error) {
	if mock.DeleteObjectFunc == nil {
		panic("clientMock.DeleteObjectFunc: method is nil but client.DeleteObject was just called")
	}
	callInfo := struct {
		Object *s3.DeleteObjectInput
	}{
		Object: object,
	}
	mock.lockDeleteObject.Lock()
	mock.calls.DeleteObject = append(mock.calls.DeleteObject, callInfo)
	mock.lockDeleteObject.Unlock()
	return mock.DeleteObjectFunc(object)
}

// DeleteObjectCalls gets all the calls that were made to DeleteObject.
// Check the length with:
//
//	len(mockedclient.DeleteObjectCalls())
func (mock *clientMock) DeleteObjectCalls() []struct {
	Object *s3.DeleteObjectInput
} {
	var calls []struct {
		Object *s3.DeleteObjectInput
	}
	mock.lockDeleteObject.RLock()
	calls = mock.calls.DeleteObject
	mock.lockDeleteObject.RUnlock()
	return calls
}

// HeadBucket calls HeadBucketFunc.
func (mock *clientMock) HeadBucket(headBucketInput *s3.HeadBucketInput) (*s3.HeadBucketOutput, error) {
	if mock.HeadBucketFunc == nil {
		panic("clientMock.HeadBucketFunc: method is nil but client.HeadBucket was just called")
	}
	callInfo := struct {
		HeadBucketInput *s3.HeadBucketInput
	}{
		HeadBucketInput: headBucketInput,
	}
	mock.lockHeadBucket.Lock()
	mock.calls.HeadBucket = append(mock.calls.HeadBucket, callInfo)
	mock.lockHeadBucket.Unlock()
	return mock.HeadBucketFunc(headBucketInput)
}

// HeadBucketCalls gets all the calls that were made to HeadBucket.
// Check the length with:
//
//	len(mockedclient.HeadBucketCalls())
func (mock *clientMock) HeadBucketCalls() []struct {
	HeadBucketInput *s3.HeadBucketInput
} {
	var calls []struct {
		HeadBucketInput *s3.HeadBucketInput
	}
	mock.lockHeadBucket.RLock()
	calls = mock.calls.HeadBucket
	mock.lockHeadBucket.RUnlock()
	return calls
}

// ListObjectsV2 calls ListObjectsV2Func.
func (mock *clientMock) ListObjectsV2(listObjectsV2Input *s3.ListObjectsV2Input) (*s3.ListObjectsV2Output, error) {
	if mock.ListObjectsV2Func == nil {
		panic("clientMock.ListObjectsV2Func: method is nil but client.ListObjectsV2 was just called")
	}
	callInfo := struct {
		ListObjectsV2Input *s3.ListObjectsV2Input
	}{
		ListObjectsV2Input: listObjectsV2Input,
	}
	mock.lockListObjectsV2.Lock()
	mock.calls.ListObjectsV2 = append(mock.calls.ListObjectsV2, callInfo)
	mock.lockListObjectsV2.Unlock()
	return mock.ListObjectsV2Func(listObjectsV2Input)
}

// ListObjectsV2Calls gets all the calls that were made to ListObjectsV2.
// Check the length with:
//
//	len(mockedclient.ListObjectsV2Calls())
func (mock *clientMock) ListObjectsV2Calls() []struct {
	ListObjectsV2Input *s3.ListObjectsV2Input
} {
	var calls []struct {
		ListObjectsV2Input *s3.ListObjectsV2Input
	}
	mock.lockListObjectsV2.RLock()
	calls = mock.calls.ListObjectsV2
	mock.lockListObjectsV2.RUnlock()
	return calls
}
